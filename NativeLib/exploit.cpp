#include "exploit.hpp"

#include <lua.h>
#include <lualib.h>
#include <Luau/Common.h>
#include <Luau/ExperimentalFlags.h>

#include "../reflection/instance.hpp"
#include "../roblox/update.hpp"
#include "../utils/utils.hpp"
#include "taskscheduler/taskscheduler.hpp"
#include "execution/execution.hpp"
#include "environment/environment.hpp"
#include "LuaUI.hpp"

// resets our stuff
void exploit::leave( )
{
    auto TS = taskscheduler::get_singleton( );
    
    TS->set_CurrentSC( 0 );
    TS->set_ExploitState( nullptr );
    
    execution::get_singleton( )->clearqueues( );
    DummyLScript = 0;
}

bool exploit::start( std::uintptr_t job )
{
    using namespace roblox;
    
    auto TS = taskscheduler::get_singleton();
    //TS->log_jobs( );
    
    auto scriptcontext = *reinterpret_cast<std::uintptr_t*>(job + 360);
    if ( !scriptcontext )
    {
        LOGE(" Failed to get ScriptContext.");
        return false;
    }
    LOGD(" Job: 0x%X, Script Context: 0x%X", job, scriptcontext );
    
    auto rL = reinterpret_cast<lua_State*>(roblox::addresses::rLEnc( scriptcontext ));
    if ( !rL )
    {
        LOGE(" Failed to get RLState.");
        return false;
    }
    LOGD(" RLState: %p", rL );
    
    // set luau flags 
    for (Luau::FValue<bool>* flag = Luau::FValue<bool>::list; flag; flag = flag->next)
        if (strncmp(flag->name, "Luau", 4) == 0)
            flag->value = true;
    
    // set globals for the exploit.
    TS->set_CurrentSC( scriptcontext );
    LOGD(" ScriptContext: 0x%X", TS->get_CurrentSC( ));
    
    TS->set_ExploitState( functions::rlua_newthread( rL ) );
    lua_ref(rL, -1); // no gc our thread 
    lua_pop(rL, 1); // pop our thread from rbx stack
    LOGD(" ExploitState: %p", TS->get_ExploitState( ));
    
    auto ls = TS->get_ExploitState( );
    if ( !ls )
    {
        LOGE(" Failed to create a new thread.");
        return false;
    }
    
    // could do something like std::call_once for this
    execution::get_singleton( )->hook_script_job( job );
    
    functions::set_identity(ls, 8);
    luaL_sandboxthread(ls);
    
    lua_newtable(ls);
    lua_setglobal(ls, "_G");
    
    lua_newtable(ls);
    lua_setglobal(ls, "shared");
    
    environment::registry_init(ls);
    lua_settop(ls, 0); // emptystack
    
    execution::get_singleton( )->schedule( LuaUI );
    return true;
}