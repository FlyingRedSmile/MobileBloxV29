#include "exploit.hpp"

#include <lua.h>
#include <lualib.h>
#include <Luau/Common.h>
#include <Luau/ExperimentalFlags.h>

#include "../reflection/instance.hpp"
#include "../roblox/update.hpp"
#include "../utils/utils.hpp"
#include "taskscheduler/taskscheduler.hpp"
#include "execution/execution.hpp"
#include "environment/environment.hpp"
#include "LuaUI.hpp"

void exploit::start( )
{
	using namespace roblox;
    
	for (Luau::FValue<bool>* flag = Luau::FValue<bool>::list; flag; flag = flag->next)
        if (strncmp(flag->name, "Luau", 4) == 0 && !Luau::isFlagExperimental(flag->name))
            flag->value = true;
    
	auto TS = taskscheduler::get_singleton( );
	auto tsc = TS->get_scriptcontext( );
	while ( tsc == TS->get_CurrentSC( ) ) { tsc = TS->get_scriptcontext( ); }
	TS->set_CurrentSC( tsc );
	LOGD(" ScriptContext: 0x%X", TS->get_CurrentSC( ));
	
	//TS->log_jobs( );
	
	auto rL = TS->get_mainstate( );
	LOGD(" RLState: %p", rL );
	
	TS->set_ExploitState( functions::rlua_newthread( rL ) );
	lua_ref(rL, -1); // no gc our thread 
	lua_pop(rL, 1); // pop our thread from rbx stack
	LOGD(" ExploitState: %p", TS->get_ExploitState( ));
	
	auto ls = TS->get_ExploitState( );
	
	execution::get_singleton( )->hook_script_job( );
	
	functions::set_identity(ls, 8);
	luaL_sandboxthread(ls);
	
	lua_newtable(ls);
	lua_setglobal(ls, "_G");
	
	lua_newtable(ls);
	lua_setglobal(ls, "shared");
	
	environment::registry_init(ls);
	lua_settop(ls, 0);
	
	execution::get_singleton( )->schedule( LuaUI );
}